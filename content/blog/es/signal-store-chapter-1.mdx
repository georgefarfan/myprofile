---
title: "C√≥mo usar Signal Store en Angular: Creando una Todo App Completa (Cap√≠tulo 1)"
excerpt: "Ejemplo pr√°ctico de c√≥mo construir un gestor de tareas con Angular 20 usando Signal Store, Tailwind CSS y persistencia en localStorage."
date: "2025-09-16"
tags: ["angular", "ngrx", "signals", "tailwind", "frontend"]
cover: "https://jorge-farfan.vercel.app/images/ngrx.png"
published: true
---

# C√≥mo usar Signal Store en Angular: Creando una Todo App Completa (Cap√≠tulo 1)

¬°Hola!  

Durante a√±os he estado trabajando con **NgRx Store cl√°sico** y **Component Store** en mis proyectos de Angular, y aunque son herramientas poderosas, siempre sent√≠ que hab√≠a **demasiado boilerplate y configuraci√≥n** para casos de uso simples.  

Todo cambi√≥ cuando llegaron los **Signals con Angular 17**.  

Desde entonces, he estado experimentando con **Signal Store** tanto en proyectos personales como a nivel profesional, y debo decir que la experiencia ha sido **reveladora**. La **simplicidad** y **elegancia** que aporta es impresionante.  

En este **primer cap√≠tulo** quiero compartir contigo esa experiencia pr√°ctica.  

Te mostrar√© c√≥mo crear una **Todo App completa**, donde utilizaremos los distintos **hooks de Signal Store**, as√≠ como la **interacci√≥n fluida con los componentes UI** que los invocan, ya sea para consultar datos del store o para modificarlos.  

Este proyecto implementar√° una **aplicaci√≥n de tareas (TODOs)** en **Angular 20** usando:  

- **Signal Store** (`@ngrx/signals`) para gestionar el estado reactivo.
- **Tailwind CSS** para el dise√±o r√°pido y responsivo.
- Persistencia en `localStorage`.
- Funcionalidad de **crear, marcar como completadas, editar en l√≠nea, borrar y filtrar tareas**.

---

## ¬øQu√© es Signal Store?

Signal Store es la nueva forma de manejar estado en Angular usando la potencia de los Signals. A diferencia del NgRx tradicional, Signal Store ofrece:

- **Menos boilerplate**: Menos c√≥digo, m√°s productividad
- **Reactividad inmediata**: Los cambios se propagan autom√°ticamente
- **Sintaxis intuitiva**: F√°cil de leer y mantener
- **Integraci√≥n nativa**: Dise√±ado espec√≠ficamente para Angular Signals

### √ösalo cuando:

- Quieres estado sencillo (todos, carrito, theme)
- Buscas productividad y menos c√≥digo
- Est√°s en Angular 17+
- Tu equipo prefiere simplicidad sobre complejidad

### Evita usarlo cuando:

- Tu proyecto depende de NgRx cl√°sico y DevTools
- Necesitas auditor√≠a avanzada de todas las acciones
- Tienes flujos extremadamente complejos
- Requieres time-travel debugging avanzado

---

## Implementaci√≥n: Creando nuestro Store

Ahora vamos a construir nuestro Todo Store paso a paso:

Store: `todo.store.ts`
```ts
import {
  signalStore,
  withState,
  withComputed,
  withMethods,
  withHooks,
  patchState,
} from '@ngrx/signals';
import { computed, effect, untracked } from '@angular/core';

type Todo = { id: number; text: string; done: boolean };

export const TodoStore = signalStore(
  withState({
    todos: [] as Todo[],
    filter: 'all' as 'all' | 'active' | 'done',
  }),

  withComputed((s) => ({
    total: computed(() => s.todos().length),
    active: computed(() => s.todos().filter((t) => !t.done)),
    done: computed(() => s.todos().filter((t) => t.done)),
    visible: computed(() => {
      switch (s.filter()) {
        case 'active':
          return s.todos().filter((t) => !t.done);
        case 'done':
          return s.todos().filter((t) => t.done);
        default:
          return s.todos();
      }
    }),
  })),

  withMethods((s) => ({
    add(text: string) {
      const id = s.todos().length + 1;
      patchState(s, { todos: [...s.todos(), { id, text, done: false }] });
    },
    toggle(id: number) {
      patchState(s, {
        todos: s
          .todos()
          .map((t) => (t.id === id ? { ...t, done: !t.done } : t)),
      });
    },
    remove(id: number) {
      patchState(s, { todos: s.todos().filter((t) => t.id !== id) });
    },
    setFilter(f: 'all' | 'active' | 'done') {
      patchState(s, { filter: f });
    },
    rename(id: number, text: string) {
      patchState(s, {
        todos: s.todos().map((t) => (t.id === id ? { ...t, text } : t)),
      });
    },
    restore() {
      const raw = localStorage.getItem('todos');
      if (!raw) return;
      const data: Todo[] = JSON.parse(raw);
      untracked(() => patchState(s, { todos: data }));
    },
  })),

  withHooks((store) => ({
    onInit() {
      store.restore();

      effect(() => {
        const data = store.todos();
        localStorage.setItem('todos', JSON.stringify(data));
      });
    },
  }))
);

```
 

### Desglosando el Store:

- **withState:** Define el estado inicial
- **withComputed:** Crea valores derivados que se actualizan autom√°ticamente
- **withMethods:** Define las acciones que pueden modificar el estado
- **withHooks:** Maneja efectos secundarios como la persistencia

---

## Componente: `app.component.ts`

```ts
import { Component, inject } from '@angular/core';
import { CommonModule, NgClass } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { bootstrapApplication } from '@angular/platform-browser';
import { TodoStore } from './todo.store';

@Component({
  selector: 'app-root',
  imports: [CommonModule, FormsModule, NgClass],
  providers: [TodoStore],
  styleUrls: ['./styles.css'],
  template: `
    <div class="max-w-md mx-auto p-4 bg-white dark:bg-slate-800 rounded-xl shadow">
      <h2 class="text-xl font-bold mb-4 text-slate-900 dark:text-slate-100">Todos</h2>


      <form (ngSubmit)="store.add(newText); newText='';" class="flex gap-2 mb-4">
        <input [(ngModel)]="newText" name="newText"
               class="border rounded-lg px-3 py-2 flex-1 dark:bg-slate-900 dark:border-slate-700 dark:text-white"
               placeholder="New task..." />
        <button class="px-3 py-2 rounded-lg bg-indigo-600 text-white hover:bg-indigo-700">Add</button>
      </form>

      <div class="flex gap-2 mb-4">
        <button class="px-2 py-1 rounded border" (click)="store.setFilter('all')">All</button>
        <button class="px-2 py-1 rounded border" (click)="store.setFilter('active')">Actives</button>
        <button class="px-2 py-1 rounded border" (click)="store.setFilter('done')">Completed</button>
      </div>

      <ul class="space-y-2">
        <li *ngFor="let t of store.visible()" class="flex items-center justify-between">
          <div class="flex items-center gap-2">
            <input type="checkbox" [checked]="t.done" (change)="store.toggle(t.id)" />
            
             <span
              *ngIf="editingId !== t.id"
              (click)="startEdit(t)"
              [ngClass]="{'line-through text-slate-400': t.done}"
              class="cursor-pointer dark:text-slate-100"
              title="Click para editar"
            >
              {{ t.text }}
            </span>
 
            <input
              *ngIf="editingId === t.id"
              [(ngModel)]="editText"
              name="edit-{{t.id}}"
              class="border rounded px-2 py-1 dark:bg-slate-900 dark:border-slate-700 dark:text-white"
              (blur)="commitEdit()"
              (keydown.enter)="commitEdit()"
              (keydown.escape)="cancelEdit()"
              autofocus
            />
          </div>

          <button (click)="store.remove(t.id)">‚ùå</button>
        </li>
      </ul>
      
      <p class="mt-4 text-sm text-slate-500 dark:text-slate-300">
        Total: {{ store.total() }} |
        Actives: {{ store.active().length }} |
        Completed: {{ store.done().length }}
      </p>
 
    </div>
  `,
  standalone: true,
})
export class App {
  store = inject(TodoStore);
  newText = '';

  editingId: number | null = null;
  editText = '';

  startEdit(t: { id: number; text: string }) {
    this.editingId = t.id;
    this.editText = t.text;
  }

  commitEdit() {
    if (this.editingId == null) return;
    const text = this.editText.trim();
    if (text) this.store.rename(this.editingId, text);
    this.cancelEdit();
  }

  cancelEdit() {
    this.editingId = null;
    this.editText = '';
  }
}

bootstrapApplication(App);

```

### C√≥mo funciona la comunicaci√≥n App ‚Üî Store

Ahora que ya vimos el c√≥digo, vamos a entender c√≥mo se comunica nuestra aplicaci√≥n con el Store y qu√© hace cada bot√≥n y acci√≥n:
El componente consume los datos del store de manera reactiva:

```ts
{{ store.total() }}           // N√∫mero total de tareas
{{ store.active().length }}   // Tareas pendientes
{{ store.done().length }}     // Tareas completadas
store.visible()               // Lista filtrada seg√∫n el filtro activo
```

### Enviando acciones al Store (App ‚Üí Store)
Cada interacci√≥n del usuario dispara una acci√≥n espec√≠fica:

#### Agregar nueva tarea

```html
<form (ngSubmit)="store.add(newText); newText='';">
```

- Qu√© hace: Crea una nueva tarea con el texto ingresado.

- C√≥mo funciona: **store.add()** recibe el texto y lo agrega al array de todos.

#### Marcar tarea como completada/pendiente
```html
<input type="checkbox" [checked]="t.done" (change)="store.toggle(t.id)" />
```

- Qu√© hace: Alterna el estado done de la tarea.

- C√≥mo funciona: **store.toggle()** busca la tarea por ID y cambia su estado.

#### Editar tarea en l√≠nea

```html
<span (click)="startEdit(t)">{{ t.text }}</span>
<input (blur)="commitEdit()" (keydown.enter)="commitEdit()" />
```

- Qu√© hace: Permite editar el texto de la tarea haciendo click

- C√≥mo funciona:
    - **startEdit()**: activa el modo edici√≥n
    - **commitEdit()** llama a **store.rename()** para actualizar el texto

#### Eliminar tarea
```html
<button (click)="store.remove(t.id)">‚ùå</button>
```

- Qu√© hace: Elimina completamente la tarea

- C√≥mo funciona: **store.remove()** filtra el array removiendo la tarea con ese ID

#### Filtrar tareas

```html
<button (click)="store.setFilter('all')">All</button>
<button (click)="store.setFilter('active')">Actives</button>
<button (click)="store.setFilter('done')">Completed</button>
```

- Qu√© hace: Cambia la vista para mostrar todas, pendientes o completadas

- C√≥mo funciona: **store.setFilter()** actualiza el estado filter, y autom√°ticamente **store.visible()** se recalcula

### Persistencia autom√°tica

Cada vez que cambia el estado de todos, se activa autom√°ticamente:

```ts
effect(() => {
  const data = store.todos();
  localStorage.setItem('todos', JSON.stringify(data));
});
```

Y al inicializar la app, se restauran los datos:
```ts
onInit() {
  store.restore();  
}
```

No necesitas manejar manualmente cu√°ndo guardar - Signal Store lo hace reactivamente.

<img src="/images/todo-app-1.png" alt="Preview of the Todo App" width="600" />

---

## Ventajas de Signal Store

- **Sencillez**: Menos boilerplate que NgRx cl√°sico
- **Reactividad inmediata**: Los cambios se propagan autom√°ticamente
- Derivados claros con withComputed
- Integraci√≥n directa con Angular Signals
- Persistencia simple con **effect()** y **restore()**
- **Mejor developer experience:** C√≥digo m√°s legible y mantenible 

---

## Desventajas

- **Muy nuevo**: Todav√≠a en evoluci√≥n, puede cambiar
- **Menos tooling**: No tiene el ecosistema maduro de NgRx Redux
- Menos probado en aplicaciones empresariales gigantes
- **Curva de aprendizaje**: Requiere entender nuevos patrones

---

## Conclusi√≥n

Como pudiste ver, construimos una aplicaci√≥n completamente funcional utilizando los diferentes hooks que nos provee Signal Store (withState, withComputed, withMethods, withHooks) en combinaci√≥n con las acciones del componente para la edici√≥n en l√≠nea y manejo de formularios.

Lo puntual de este enfoque est√° en c√≥mo Signal Store maneja autom√°ticamente toda la reactividad mientras que el componente se enfoca √∫nicamente en la l√≥gica de presentaci√≥n espec√≠fica (como el modo de edici√≥n). El resultado es un c√≥digo limpio, mantenible y sorprendentemente compacto para toda la funcionalidad que ofrece.

Signal Store es una excelente opci√≥n para la mayor√≠a de apps modernas en Angular 17+, especialmente si priorizas:

- ‚ö° Productividad sobre configuraci√≥n compleja
- üßπ C√≥digo limpio sobre flexibilidad extrema
- üöÄ Desarrollo √°gil sobre herramientas de debugging avanzadas

Para proyectos empresariales con requisitos de auditor√≠a estrictos, efectos distribuidos complejos y necesidad de time-travel debugging, NgRx Redux-style sigue siendo una opci√≥n s√≥lida.

¬øQu√© te parece esta aproximaci√≥n? En el pr√≥ximo cap√≠tulo veremos c√≥mo escalar Signal Store para aplicaciones m√°s complejas y integrar middleware personalizado.